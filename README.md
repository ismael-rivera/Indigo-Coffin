# Indigo-Coffin
Error Handling in Node.js Error handling is a pain, and it's easy to get by for a long time in Node.js without dealing with many errors correctly. But building robust Node.js apps requires dealing properly with errors, and it's not hard to learn how. If you're really impatient, skip down to the "Summary" section for a tl;dr.  This document will answer several questions that programmers new to Node.js often ask:  In functions that I write, when should I throw an error, and when should I emit it with a callback, event emitter, or something else? What should my functions assume about their arguments? Should I check that they're the correct types? Should I check more specific constraints, like that an argument is non-null, is non-negative, looks like an IP address, or the like? How should I deal with arguments that don't match what the function expects? Should I throw an exception or emit an error to the callback? How can I programmatically distinguish between different kinds of errors (e.g., a "Bad Request" error vs. a "Service Unavailable" error)? How can I provide enough detail with my errors so that callers can know what to do about them? How should I handle unexpected errors? Should I use try/catch, domains, or something else? This document is divided into several parts that build on one another:  Background: what you're expected to know already. Operational errors vs. programmer errors: introduction to two fundamentally different kinds of errors Patterns for writing functions: general principles for writing functions that produce useful errors Specific recommendations for writing new functions: a checklist of specific guidelines for writing robust functions that produce useful errors An example: example documentation and preamble for a connect function Summary: a summary of everything up to this point Appendix: Conventional properties for Error objects: a list of property names to use for providing extra information in a standard way
